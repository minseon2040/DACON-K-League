# -*- coding: utf-8 -*-
"""utils.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1h5zdb8tj8Yfe33TKe0gN3E2qy4QI7Ws2
"""

import numpy as np

# 공통 설정/평가/앙상블
def metric(true_dx, true_dy, pred_dx, pred_dy):
    return float(np.mean(np.sqrt((true_dx - pred_dx)**2 + (true_dy - pred_dy)**2)))

def bucket_from_dist(d):
    if d < 20:
        return "short"
    elif d < 35:
        return "mid"
    else:
        return "long"

def weights_from_oof_scores(scores, alpha=0.5, eps=1e-6):
    scores = np.array(scores, dtype=float)
    w = 1.0 / np.power(scores + eps, alpha)
    w = w / w.sum()
    return w

def weighted_sum2(a1, a2, w1, w2):
    return w1 * a1 + w2 * a2

# bucket별 weight voting
def compute_bucket_weights(y_dx, y_dy, cb_oof_dx, cb_oof_dy, lgb_oof_dx, lgb_oof_dy, alpha=0.5):
    dist = np.sqrt(y_dx**2 + y_dy**2)
    buckets = np.array([bucket_from_dist(d) for d in dist])

    weights = {}
    for b in ["short", "mid", "long"]:
        idx = np.where(buckets == b)[0]
        if len(idx) == 0:
            weights[b] = (0.5, 0.5)
            continue

        cb_s = metric(y_dx[idx], y_dy[idx], cb_oof_dx[idx], cb_oof_dy[idx])
        lg_s = metric(y_dx[idx], y_dy[idx], lgb_oof_dx[idx], lgb_oof_dy[idx])

        w = weights_from_oof_scores([cb_s, lg_s], alpha=alpha)
        weights[b] = (float(w[0]), float(w[1]))
    return weights

def apply_bucket_ensemble(dx_a, dy_a, dx_b, dy_b, weights, dist_ref):
    """
    bucket별 weights를 적용해서 (dx,dy) 가중 평균 앙상블
    dx_a/dy_a: 모델A 예측 (N,)
    dx_b/dy_b: 모델B 예측 (N,)
    weights: {"short":(wA,wB), "mid":(...), "long":(...)}
    dist_ref: 버킷 구분 기준 거리 (N,)  - OOF는 true dist, TEST는 pred dist 사용
    """
    buckets = np.array([bucket_from_dist(float(d)) for d in dist_ref])

    out_dx = np.zeros_like(dx_a, dtype=np.float32)
    out_dy = np.zeros_like(dy_a, dtype=np.float32)

    for b in ["short", "mid", "long"]:
        idx = np.where(buckets == b)[0]
        if len(idx) == 0:
            continue
        w_a, w_b = weights[b]
        out_dx[idx] = (w_a * dx_a[idx] + w_b * dx_b[idx]).astype(np.float32)
        out_dy[idx] = (w_a * dy_a[idx] + w_b * dy_b[idx]).astype(np.float32)

    return out_dx, out_dy

# 5) Carry cap 후처리

def apply_carry_hard_caps(dx, dy, df_like, caps):
    dx = dx.copy()
    dy = dy.copy()

    pred_dist = np.sqrt(dx**2 + dy**2)

    for role, cap in caps.items():
        mask = (
            (df_like["player_role_pass"] == role) &
            (df_like["prev1_action_type"] == "Carry") &
            (pred_dist > cap)
        )
        if mask.sum() == 0:
            continue

        scale = cap / pred_dist[mask]
        dx[mask] *= scale
        dy[mask] *= scale

    return dx, dy